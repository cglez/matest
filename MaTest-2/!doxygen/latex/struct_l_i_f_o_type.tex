ring_offset)),
				rx_ring, pkt_size - (RX_BUF_LEN - rx_ring_offset));
		} else {
			memcpy(skb_put(skb, pkt_size), rx_ring + rx_ring_offset, pkt_size);
		}

		skb->protocol = eth_type_trans(skb, dev);
		netif_rx(skb);

		dev->stats.rx_bytes += pkt_size;
		dev->stats.rx_packets++;

		if (rx_status & Rx_Multicast)
			dev->stats.multicast++;

	next:
		rx_ring_offset = (rx_ring_offset + rx_size_align) % RX_BUF_LEN;
	}
	mb();

	priv->rx_ring_tail = rx_ring_head;
	iowrite32(priv->rx_ring_tail, port_base + RxBufRPtr);
}

static void _sc92031_link_tasklet(struct net_device *dev)
{
	if (_sc92031_check_media(dev))
		netif_wake_queue(dev);
	else {
		netif_stop_queue(dev);
		dev->stats.tx_carrier_errors++;
	}
}

static void sc92031_tasklet(unsigned long data)
{
	struct net_device *dev = (struct net_device *)data;
	struct sc92031_priv *priv = netdev_priv(dev);
	void __iomem *port_base = priv->port_base;
	u32 intr_status, intr_mask;

	intr_status = priv->intr_status;

	spin_lock(&priv->lock);

	if (unlikely(!netif_running(dev)))
		goto out;

	if (intr_status &