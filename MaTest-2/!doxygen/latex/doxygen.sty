fine HALF_DUP_TX		0x1000
#define HALF_DUP_RX		0x2000


/*
 * Error codes
 */

/* Host Error Codes - values of fail1 */
#define ERR_UNKNOWN_MBOX	0x1001
#define ERR_UNKNOWN_CMD		0x1002
#define ERR_MAX_RING		0x1003
#define ERR_RING_CLOSED		0x1004
#define ERR_RING_OPEN		0x1005
/* Firmware internal errors */
#define ERR_EVENT_RING_FULL	0x01
#define ERR_DW_PEND_CMND_FULL	0x02
#define ERR_DR_PEND_CMND_FULL	0x03
#define ERR_DW_PEND_DATA_FULL	0x04
#define ERR_DR_PEND_DATA_FULL	0x05
#define ERR_ILLEGAL_JUMP	0x06
#define ERR_UNIMPLEMENTED	0x07
#define ERR_TX_INFO_FULL	0x08
#define ERR_RX_INFO_FULL	0x09
#define ERR_ILLEGAL_MODE	0x0A
#define ERR_MAIN_TIMEOUT	0x0B
#define ERR_EVENT_BITS		0x0C
#define ERR_UNPEND_FULL		0x0D
#define ERR_TIMER_QUEUE_FULL	0x0E
#define ERR_TIMER_QUEUE_EMPTY	0x0F
#define ERR_TIMER_NO_FREE	0x10
#define ERR_INTR_START		0x11
#define ERR_BAD_STARTUP		0x12
#define ERR_NO_PKT_END		0x13
#define ERR_HALTED_ON_ERR	0x14
/* Hardware NIC Errors */
#define ERR_WRITE_DMA		0x0101
#define ERR_READ_DMA		0x0102
#define ERR_EXT_SERIAL		0x0103
#define ERR_TX_INT_PARITY	0x0104


/*
 * Event definitions
 */

#define EVT_RING_ENTRIES	64
#define EVT_RING_SIZE		(EVT_RING_ENTRIES * sizeof(struct event))

struct event {
#ifdef __LITTLE_ENDIAN
	u16     index;
	u8      ring;
	u8      code;
#else
	u8      code;
	u8      ring;
	u16     index;
#endif
	u32     timestamp;
};

/*
 * General Events
 */

#define E_NIC_UP	0x01
#define E_WATCHDOG	0x02

#define E_STAT_UPD	0x04
#define E_INVAL_CMD	0x05
#define E_SET_CMD_CONS	0x06
#define E_LINK_ON	0x07
#define E_LINK_OFF	0x08
#define E_INTERN_ERR	0x09
#define E_HOST_ERR	0x0A
#define E_STATS_UPDATE	0x0B
#define E_REJECTING	0x0C

/*
 * Send  Events
 */
#define E_CON_REJ	0x13
#define E_CON_TMOUT	0x14
#define E_CON_NC_TMOUT	0x15	/* I  , Connection No Campon Timeout */
#define E_DISC_ERR	0x16
#define E_INT_PRTY	0x17
#define E_TX_IDLE	0x18
#define E_TX_LINK_DROP	0x19
#define E_TX_INV_RNG	0x1A
#define E_TX_INV_BUF	0x1B
#define E_TX_INV_DSC	0x1C

/*
 * Destination Events
 */
/*
 * General Receive events
 */
#define E_VAL_RNG	0x20
#define E_RX_RNG_ENER	0x21
#define E_INV_RNG	0x22
#define E_RX_RNG_SPC	0x23
#define E_RX_RNG_OUT	0x24
#define E_PKT_DISCARD	0x25
#define E_INFO_EVT	0x27

/*
 * Data corrupted events
 */
#define E_RX_PAR_ERR	0x2B
#define E_RX_LLRC_ERR	0x2C
#define E_IP_CKSM_ERR	0x2D
#define E_DTA_CKSM_ERR	0x2E
#define E_SHT_BST	0x2F

/*
 * Data lost events
 */
#define E_LST_LNK_ERR	0x30
#define E_FLG_SYN_ERR	0x31
#define E_FRM_ERR	0x32
#define E_RX_IDLE	0x33
#define E_PKT_LN_ERR	0x34
#define E_STATE_ERR	0x35
#define E_UNEXP_DATA	0x3C

/*
 * Fatal events
 */
#define E_RX_INV_BUF	0x36
#define E_RX_INV_DSC	0x37
#define E_RNG_BLK	0x38

/*
 * Warning events
 */
#define E_RX_TO		0x39
#define E_BFR_SPC	0x3A
#define E_INV_ULP	0x3B

#define E_NOT_IMPLEMENTED 0x40


/*
 * Commands
 */

#define CMD_RING_ENTRIES	16

struct cmd {
#ifdef __LITTLE_ENDIAN
	u16     index;
	u8      ring;
	u8      code;
#else
	u8      code;
	u8      ring;
	u16     index;
#endif
};

#define C_START_FW	0x01
#define C_UPD_STAT	0x02
#define C_WATCHDOG	0x05
#define C_DEL_RNG	0x09
#define C_NEW_RNG	0x0A
#define C_CONN		0x0D


/*
 * Mode bits
 */

#define  PACKET_BAD		0x01 /* Packet had link-layer error */
#define  INTERRUPT		0x02
#define  TX_IP_CKSUM		0x04
#define  PACKET_END		0x08
#define  PACKET_START		0x10
#define  SAME_IFIELD		0x80


typedef struct {
#if (BITS_PER_LONG == 64)
	u64 addrlo;
#else
	u32 addrhi;
	u32 addrlo;
#endif
} rraddr;


static inline void set_rraddr(rraddr *ra, dma_addr_t addr)
{
	unsigned long baddr = addr;
#if (BITS_PER_LONG == 64)
	ra->addrlo = baddr;
#else
    /* Don't bother setting zero every time */
	ra->addrlo = baddr;
#endif
	mb();
}


static inline void set_rxaddr(struct rr_regs __iomem *regs, volatile dma_addr_t addr)
{
	unsigned long baddr = addr;
#if (BITS_PER_LONG == 64) && defined(__LITTLE_ENDIAN)
	writel(baddr & 0xffffffff, &regs->RxRingHi);
	writel(baddr >> 32, &regs->RxRingLo);
#elif (BITS_PER_LONG == 64)
	writel(baddr >> 32, &regs->RxRingHi);
	writel(baddr & 0xffffffff, &regs->RxRingLo);
#else
	writel(0, &regs->RxRingHi);
	writel(baddr, &regs->RxRingLo);
#endif
	mb();
}


static inline void set_infoaddr(struct rr_regs __iomem *regs, volatile dma_addr_t addr)
{
	unsigned long baddr = addr;
#if (BITS_PER_LONG == 64) && defined(__LITTLE_ENDIAN)
	writel(baddr & 0xffffffff, &regs->InfoPtrHi);
	writel(baddr >> 32, &regs->InfoPtrLo);
#elif (BITS_PER_LONG == 64)
	writel(baddr >> 32, &regs->InfoPtrHi);
	writel(baddr & 0xffffffff, &regs->InfoPtrLo);
#else
	writel(0, &regs->InfoPtrHi);
	writel(baddr, &regs->InfoPtrLo);
#endif
	mb();
}


/*
 * TX ring
 */

#ifdef CONFIG_ROADRUNNER_LARGE_RINGS
#define TX_RING_ENTRIES	32
#else
#define TX_RING_ENTRIES	16
#endif
#define TX_TOTAL_SIZE	(TX_RING_ENTRIES * sizeof(struct tx_desc))

struct tx_desc{
	rraddr	addr;
	u32	res;
#ifdef __LITTLE_ENDIAN
	u16	size;
	u8	pad;
	u8	mode;
#else
	u8	mode;
	u8	pad;
	u16	size;
#endif
};


#ifdef CONFIG_ROADRUNNER_LARGE_RINGS
#define RX_RING_ENTRIES	32
#else
#define RX_RING_ENTRIES 16
#endif
#define RX_TOTAL_SIZE	(RX_RING_ENTRIES * sizeof(struct rx_desc))

struct rx_desc{
	rraddr	addr;
	u32	res;
#ifdef __LITTLE_ENDIAN
	u16	size;
	u8	pad;
	u8	mode;
#else
	u8	mode;
	u8	pad;
	u16	size;
#endif
};


/*
 * ioctl's
 */

#define SIOCRRPFW	SIOCDEVPRIVATE		/* put firmware */
#define SIOCRRGFW	SIOCDEVPRIVATE+1	/* get firmware */
#define SIOCRRID	SIOCDEVPRIVATE+2	/* identify */


struct seg_hdr {
	u32	seg_start;
	u32	seg_len;
	u32	seg_eestart;
};


#define EEPROM_BASE 0x80000000
#define EEPROM_WORDS 8192
#define EEPROM_BYTES (EEPROM_WORDS * sizeof(u32))

struct eeprom_boot {
	u32	key1;
	u32	key2;
	u32	sram_size;
	struct	seg_hdr loader;
	u32	init_chksum;
	u32	reserved1;
};

struct eeprom_manf {
	u32	HeaderFmt;
	u32	Firmware;
	u32	BoardRevision;
	u32	RoadrunnerRev;
	char	OpticsPart[8];
	u32	OpticsRev;
	u32	pad1;
	char	SramPart[8];
	u32	SramRev;
	u32	pad2;
	char	EepromPart[8];
	u32	EepromRev;
	u32	EepromSize;
	char	PalPart[8];
	u32	PalRev;
	u32	pad3;
	char	PalCodeFile[12];
	u32	PalCodeRev;
	char	BoardULA[8];
	char	SerialNo[8];
	char	MfgDate[8];
	char	MfgTime[8];
	char	ModifyDate[8];
	u32	ModCount;
	u32	pad4[13];
};


struct eeprom_phase_info {
	char	phase1File[12];
	u32	phase1Rev;
	char	phase1Date[8];
	char	phase2File[12];
	u32	phase2Rev;
	char	phase2Date[8];
	u32	reserved7[4];
};

struct eeprom_rncd_info {
	u32	FwStart;
	u32	FwRev;
	char	FwDate[8];
	u32	AddrRunCodeSegs;
	u32	FileNames;
	char	File[13][8];
};


/* Phase 1 region (starts are word offset 0x80) */
struct phase1_hdr{
	u32	jump;
	u32	noop;
	struct seg_hdr phase2Seg;
};

struct eeprom {
	struct eeprom_boot	boot;
	u32			pad1[8];
	struct eeprom_manf	manf;
	struct eeprom_phase_info phase_info;
	struct eeprom_rncd_info	rncd_info;
	u32			pad2[15];
	u32			hdr_checksum;
	struct phase1_hdr	phase1;
};


struct rr_stats {
	u32	NicTimeStamp;
	u32	RngCreated;
	u32	RngDeleted;
	u32	IntrGen;
	u32	NEvtOvfl;
	u32	InvCmd;
	u32	DmaReadErrs;
	u32	DmaWriteErrs;
	u32	StatUpdtT;
	u32	StatUpdtC;
	u32	WatchDog;
	u32	Trace;

	/* Serial HIPPI */
	u32	LnkRdyEst;
	u32	GLinkErr;
	u32	AltFlgErr;
	u32	OvhdBit8Sync;
	u32	RmtSerPrtyErr;
	u32	RmtParPrtyErr;
	u32	RmtLoopBk;
	u32	pad1;

	/* HIPPI tx */
	u32	ConEst;
	u32	ConRejS;
	u32	ConRetry;
	u32	ConTmOut;
	u32	SndConDiscon;
	u32	SndParErr;
	u32	PktSnt;
	u32	pad2[2];
	u32	ShFBstSnt;
	u64	BytSent;
	u32	TxTimeout;
	u32	pad3[3];

	/* HIPPI rx */
	u32	ConAcc;
	u32	