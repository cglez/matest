);

	bmcr = _sc92031_mii_read(port_base, MII_BMCR);
	if (!(bmcr & BMCR_ANENABLE)) {
		err = -EINVAL;
		goto out;
	}

	_sc92031_mii_write(port_base, MII_BMCR, bmcr | BMCR_ANRESTART);

out:
	_sc92031_mii_scan(port_base);
	mmiowb();

	spin_unlock_bh(&priv->lock);

	return err;
}

static const char sc92031_ethtool_stats_strings[SILAN_STATS_NUM][ETH_GSTRING_LEN] = {
	"tx_timeout",
	"rx_loss",
};

static void sc92031_ethtool_get_strings(struct net_device *dev,
		u32 stringset, u8 *data)
{
	if (stringset == ETH_SS_STATS)
		memcpy(data, sc92031_ethtool_stats_strings,
				SILAN_STATS_NUM * ETH_GSTRING_LEN);
}

static int sc92031_ethtool_get_sset_count(struct net_device *dev, int sset)
{
	switch (sset) {
	case ETH_SS_STATS:
		return SILAN_STATS_NUM;
	default:
		return -EOPNOTSUPP;
	}
}

static void sc92031_ethtool_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct sc92031_priv *priv = netdev_priv(dev);

	spin_lock_bh(&priv->lock);
	data[0] = priv->tx_timeouts;
	data[1] = priv->rx_loss;
	spin_unlock_bh(&priv->lock);
}

static const struct ethtool_ops sc92031_ethtool_ops = {
	.get_settings		= sc92031_ethtool_get_settings,
	.set_settings		= sc92031_ethtool_set_settings,
	.get_drvinfo		= sc92031_ethtool_get_drvinfo,
	.get_wol		= sc92031_ethtool_get_wol,
	.set_wol		= sc92031_ethtool_set_wol,
	.nway_reset		= sc92031_ethtool_nway_reset,
	.get_link		= ethtool_op_get_link,
	.get_strings		= sc92031_ethtool_get_strings,
	.get_sset_count		= sc92031_ethtool_get_sset_count,
	.get_ethtool_stats	= sc92031_ethtool_get_ethtool_stats,
};


static const struct net_device_ops sc92031_netdev_ops = {
	.ndo_get_stats		= sc92031_get_stats,
	.ndo_start_xmit		= sc92031_start_xmit,
	.ndo_open		= sc92031_open,
	.ndo_stop		= sc92031_s