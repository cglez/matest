bmac_uninitctx(sc);
	return err;
}


static int sbmac_open(struct net_device *dev)
{
	struct sbmac_softc *sc = netdev_priv(dev);
	int err;

	if (debug > 1)
		pr_debug("%s: sbmac_open() irq %d.\n", dev->name, dev->irq);

	/*
	 * map/route interrupt (clear status first, in case something
	 * weird is pending; we haven't initialized the mac registers
	 * yet)
	 */

	__raw_readq(sc->sbm_isr);
	err = request_irq(dev->irq, sbmac_intr, IRQF_SHARED, dev->name, dev);
	if (err) {
		printk(KERN_ERR "%s: unable to get IRQ %d\n", dev->name,
		       dev->irq);
		goto out_err;
	}

	sc->sbm_speed = sbmac_speed_none;
	sc->sbm_duplex = sbmac_duplex_none;
	sc->sbm_fc = sbmac_fc_none;
	sc->sbm_pause = -1;
	sc->sbm_link = 0;

	/*
	 * Attach to the PHY
	 */
	err = sbmac_mii_probe(dev);
	if (err)
		goto out_unregister;

	/*
	 * Turn on the channel
	 */

	sbmac_set_channel_state(sc,sbmac_state_on);

	netif_start_queue(dev);

	sbmac_set_rx_mode(dev);

	phy_start(sc->phy_dev);

	napi_enable(&sc->napi);

	return 0;

out_unregister:
	free_irq(dev->irq, dev);
out_err:
	return err;
}

static int sbmac_mii_probe(struct net_device *dev)
{
	struct sbmac_softc *sc = netdev_priv(dev);
	struct phy_device *phy_dev;
	int i;

	for (i = 0; i < PHY_MAX_ADDR; i++) {
		phy_dev = sc->mii_bus->phy_map[i];
		if (phy_dev)
			break;
	}
	if (!phy_dev) {
		printk(KERN_ERR "%s: no PHY found\n", dev->name);
		return -ENXIO;
	}

	phy_dev = phy_connect(dev, dev_name(&phy_dev->dev), &sbmac_mii_poll, 0,
			      PHY_INTERFACE_MODE_GMII);
	if (IS_ERR(phy_dev)) {
		printk(KERN_ERR "%s: could not attach to PHY\n", dev->name);
		return PTR_ERR(phy_dev);
	}

	/* Remove any features not supported by the controller */
	phy_dev->supported &= SUPPORTED_10baseT_Half |
			      SUPPORTED_10baseT_Full |
			      SUPPORTED_100baseT_Half |
			      SUPPORTED_100baseT_Full |
			      SUPPORTED_1000baseT_Half |
			      SUPPORTED_1000baseT_Full |
			      SUPPORTED_Autoneg |
			      SUPPORTED_MII |
			      SUPPORTED_Pause |
			      SUPPORTED_Asym_Pause;
	phy_dev->advertising = phy_dev->supported;

	pr_info("%s: attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
		dev->name, phy_dev->drv->name,
		dev_name(&phy_dev->dev), phy_dev->irq);

	sc->phy_dev = phy_dev;

	return 0;
}


static void sbmac_mii_poll(struct net_device *dev)
{
	struct sbmac_softc *sc = netdev_priv(dev);
	struct phy_device *phy_dev = sc->phy_dev;
	unsigned long flags;
	enum sbmac_fc fc;
	int link_chg, speed_chg, duplex_chg, pause_chg, fc_chg;

	link_chg = (sc->sbm_link != phy_dev->link);
	speed_chg = (sc->sbm_speed != phy_dev->speed);
	duplex_chg = (sc->sbm_duplex != phy_dev->duplex);
	pause_chg = (sc->sbm_pause != phy_dev->pause);

	if (!link_chg && !speed_chg && !duplex_chg && !pause_chg)
		return;					/* Hmmm... */

	if (!phy_dev->link) {
		if (link_chg) {
			sc->sbm_link = phy_dev->link;
			sc->sbm_speed = sbmac_speed_none;
			sc->sbm_duplex = sbmac_duplex_none;
			sc->sbm_fc = sbmac_fc_disabled;
			sc->sbm_pause = -1;
			pr_info("%s: link unavailable\n", dev->name);
		}
		return;
	}

	if (phy_dev->duplex == DUPLEX_FULL) {
		if (phy_dev->pause)
			fc = sbmac_fc_frame;
		else
			fc = sbmac_fc_disabled;
	} else
		fc = sbmac_fc_collision;
	fc_chg = (sc->sbm_fc != fc);

	pr_info("%s: link available: %dbase-%cD\n", dev->name, phy_dev->speed,
		phy_dev->duplex == DUPLEX_FULL ? 'F' : 'H');

	spin_lock_irqsave(&sc->sbm_lock, flags);

	sc->sbm_speed = phy_dev->speed;
	sc->sbm_duplex = phy_dev->duplex;
	sc->sbm_fc = fc;
	sc->sbm_pause = phy_dev->pause;
	sc->sbm_link = phy_dev->link;

	if ((speed_chg || duplex_chg || fc_chg) &&
	    sc->sbm_state != sbmac_state_off) {
		/*
		 * something changed, restart the channel
		 */
		if (debug > 1)
			pr_debug("%s: restarting channel "
				 "because PHY state changed\n", dev->name);
		sbmac_channel_stop(sc);
		sbmac_channel_start(sc);
	}

	spin_unlock_irqrestore(&sc->sbm_lock, flags);
}


static void sbmac_tx_timeout (struct net_device *dev)
{
	struct sbmac_softc *sc = netdev_priv(dev);
	unsigned long flags;

	spin_lock_irqsave(&sc->sbm_lock, flags);


	dev->trans_start = jiffies; /* prevent tx timeout */
	dev->stats.tx_errors++;

	spin_unlock_irqrestore(&sc->sbm_lock, flags);

	printk (KERN_WARNING "%s: Transmit timed out\n",dev->name);
}




static void sbmac_set_rx_mode(struct net_device *dev)
{
	unsigned long flags;
	struct sbmac_softc *sc = netdev_priv(dev);

	spin_lock_irqsave(&sc->sbm_lock, flags);
	if ((dev->flags ^ sc->sbm_devflags) & IFF_PROMISC) {
		/*
		 * Promiscuous changed.
		 */

		if (dev->flags & IFF_PROMISC) {
			sbmac_promiscuous_mode(sc,1);
		}
		else {
			sbmac_promiscuous_mode(sc,0);
		}
	}
	spin_unlock_irqrestore(&sc->sbm_lock, flags);

	/*
	 * Program the multicasts.  Do this every time.
	 */

	sbmac_setmulti(sc);

}

static int sbmac_mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct sbmac_softc *sc = netdev_priv(dev);

	if (!netif_running(dev) || !sc->phy_dev)
		return -EINVAL;

	return phy_mii_ioctl(sc->phy_dev, rq, cmd);
}

static int sbmac_close(struct net_device *dev)
{
	struct sbmac_softc *sc = netdev_priv(dev);

	napi_disable(&sc->napi);

	phy_stop(sc->phy_dev);

	sbmac_set_channel_state(sc, sbmac_state_off);

	netif_stop_queue(dev);

	if (debug > 1)
		pr_debug("%s: Shutting down ethercard\n", dev->name);

	phy_disconnect(sc->phy_dev);
	sc->phy_dev = NULL;
	free_irq(dev->irq, dev);

	sbdma_emptyring(&(sc->sbm_txdma));
	sbdma_emptyring(&(sc->sbm_rxdma));

	return 0;
}

static int sbmac_poll(struct napi_struct *napi, int budget)
{
	struct sbmac_softc *sc = container_of(napi, struct sbmac_softc, napi);
	int work_done;

	work_done = sbdma_rx_process(sc, &(sc->sbm_rxdma), budget, 1);
	sbdma_tx_process(sc, &(sc->sbm_txdma), 1);

	if (work_done < budget) {
		napi_complete(napi);

#ifdef CONFIG_SBMAC_COALESCE
		__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |
			     ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0),
			     sc->sbm_imr);
#else
		__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |
			     (M_MAC_INT_CHANNEL << S_MAC_RX_CH0), sc->sbm_imr);
#endif
	}

	return work_done;
}


static int __devinit sbmac_probe(struct platform_device *pldev)
{
	struct net_device *dev;
	struct sbmac_softc *sc;
	void __iomem *sbm_base;
	struct resource *res;
	u64 sbmac_orig_hwaddr;
	int err;

	res = platform_get_resource(pldev, IORESOURCE_MEM, 0);
	BUG_ON(!res);
	sbm_base = ioremap_nocache(res->start, res->end - res->start + 1);
	if (!sbm_base) {
		printk(KERN_ERR "%s: unable to map device registers\n",
		       dev_name(&pldev->dev));
		err = -ENOMEM;
		goto out_out;
	}

	/*
	 * The R_MAC_ETHERNET_ADDR register will be set to some nonzero
	 * value for us by the firmware if we're going to use this MAC.
	 * If we find a zero, skip this MAC.
	 */
	sbmac_orig_hwaddr = __raw_readq(sbm_base + R_MAC_ETHERNET_ADDR);
	pr_debug("%s: %sconfiguring MAC at 0x%08Lx\n", dev_name(&pldev->dev),
		 sbmac_orig_hwaddr ? "" : "not ", (long long)res->start);
	if (sbmac_orig_hwaddr == 0) {
		err = 0;
		goto out_unmap;
	}

	/*
	 * Okay, cool.  Initialize this MAC.
	 */
	dev = alloc_etherdev(sizeof(struct sbmac_softc));
	if (!dev) {
		printk(KERN_ERR "%s: unable to allocate etherdev\n",
		       dev_name(&pldev->dev));
		err = -ENOMEM;
		goto out_unmap;
	}

	dev_set_drvdata(&pldev->dev, dev);
	SET_NETDEV_DEV(dev, &pldev->dev);

	sc = netdev_priv(dev);
	sc->sbm_base = sbm_base;

	err = sbmac_init(pldev, res->start);
	if (err)
		goto out_kfree;

	return 0;

out_kfree:
	free_netdev(dev);
	__raw_writeq(sbmac_orig_hwaddr, sbm_base + R_MAC_ETHERNET_ADDR);

out_unmap:
	iounmap(sbm_base);

out_out:
	return err;
}

static int __exit sbmac_remove(struct platform_device *pldev)
{
	struct net_device *dev = dev_get_drvdata(&pldev->dev);
	struct sbmac_softc *sc = netdev_priv(dev);

	unregister_netdev(dev);
	sbmac_uninitctx(sc);
	mdiobus_unregister(sc->mii_bus);
	mdiobus_free(sc->mii_bus);
	iounmap(sc->sbm_base);
	free_netdev(dev);

	return 0;
}

static struct platform_driver sbmac_driver = {
	.probe = sbmac_probe,
	.remove = __exit_p(sbmac_remove),
	.driver = {
		.name = sbmac_string,
		.owner  = THIS_MODULE,
	},
};

static int __init sbmac_init_module(void)
{
	return platform_driver_register(&sbmac_driver);
}

static void __exit sbmac_cleanup_module(void)
{
	platform_driver_unregister(&sbmac_driver);
}

module_init(sbmac_init_module);
module_exit(sbmac_cleanup_module);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      