static unsigned char *dispDeviceBase __force_data;

#define cmapsz	(16*256)

static unsigned char vga_font[cmapsz];

static int __init btext_initialize(unsigned int node)
{
	unsigned int width, height, depth, pitch;
	unsigned long address = 0;
	u32 prop;

	if (prom_getproperty(node, "width", (char *)&width, 4) < 0)
		return -EINVAL;
	if (prom_getproperty(node, "height", (char *)&height, 4) < 0)
		return -EINVAL;
	if (prom_getproperty(node, "depth", (char *)&depth, 4) < 0)
		return -EINVAL;
	pitch = width * ((depth + 7) / 8);

	if (prom_getproperty(node, "linebytes", (char *)&prop, 4) >= 0 &&
	    prop != 0xffffffffu)
		pitch = prop;

	if (pitch == 1)
		pitch = 0x1000;

	if (prom_getproperty(node, "address", (char *)&prop, 4) >= 0)
		address = prop;

	/* FIXME: Add support for PCI reg properties. Right now, only
	 * reliable on macs
	 */
	if (address == 0)
		return -EINVAL;

	g_loc_X = 0;
	g_loc_Y = 0;
	g_max_loc_X = width / 8;
	g_max_loc_Y = height / 16;
	dispDeviceBase = (unsigned char *)address;
	dispDeviceRowBytes = pitch;
	dispDeviceDepth = depth == 15 ? 16 : depth;
	dispDeviceRect[0] = dispDeviceRect[1] = 0;
	dispDeviceRect[2] = width;
	dispDeviceRect[3] = height;

	return 0;
}

/* Calc the base address of a given point (x,y) */
static unsigned char * calc_base(int x, int y)
{
	unsigned char *base = dispDeviceBase;

	base += (x + dispDeviceRect[0]) * (dispDeviceDepth >> 3);
	base += (y + dispDeviceRect[1]) * dispDeviceRowBytes;
	return base;
}

static void btext_clearscreen(void)
{
	unsigned int *base	= (unsigned int *)calc_base(0, 0);
	unsigned long width 	= ((dispDeviceRect[2] - dispDeviceRect[0]) *
					(dispDeviceDepth >> 3)) >> 2;
	int i,j;

	for (i=0; i<(dispDeviceRect[3] - dispDeviceRect[1]); i++)
	{
		unsigned int *ptr = base;
		for(j=width; j; --j)
			*(ptr++) = 0;
		base += (dispDeviceRowBytes >> 2);
	}
}

#ifndef NO_SCROLL
static void scrollscreen(void)
{
	unsigned int *src     	= (unsigned int *)calc_base(0,16);
	unsigned int *dst     	= (unsigned int *)calc_base(0,0);
	unsigned long width    	= ((dispDeviceRect[2] - dispDeviceRect[0]) *
				   (dispDeviceDepth >> 3)) >> 2;
	int i,j;

	for (i=0; i<(dispDeviceRect[3] - dispDevice