OK;
}

static int sc92031_open(struct net_device *dev)
{
	int err;
	struct sc92031_priv *priv = netdev_priv(dev);
	struct pci_dev *pdev = priv->pdev;

	priv->rx_ring = pci_alloc_consistent(pdev, RX_BUF_LEN,
			&priv->rx_ring_dma_addr);
	if (unlikely(!priv->rx_ring)) {
		err = -ENOMEM;
		goto out_alloc_rx_ring;
	}

	priv->tx_bufs = pci_alloc_consistent(pdev, TX_BUF_TOT_LEN,
			&priv->tx_bufs_dma_addr);
	if (unlikely(!priv->tx_bufs)) {
		err = -ENOMEM;
		goto out_alloc_tx_bufs;
	}
	priv->tx_head = priv->tx_tail = 0;

	err = request_irq(pdev->irq, sc92031_interrupt,
			IRQF_SHARED, dev->name, dev);
	if (unlikely(err < 0))
		goto out_request_irq;

	priv->pm_config = 0;

	/* Interrupts already disabled by sc92031_stop or sc92031_probe */
	spin_lock_bh(&priv->lock);

	_sc92031_reset(dev);
	mmiowb();

	spin_unlock_bh(&priv->lock);
	sc92031_enable_interrupts(dev);

	if (netif_carrier_ok(dev))
		netif_start_queue(dev);
	else
		netif_tx_disable(dev);

	return 0;

out_request_irq:
	pci_free_consistent(pdev, TX_BUF_TOT_LEN, priv->tx_bufs,
			priv->tx_bufs_dma_addr);
out_alloc_tx_bufs:
	pci_free_consistent(pdev, RX_BUF_LEN, priv->rx_ring,
			priv->rx_ring_dma_addr);
out_alloc_rx_ring:
	return err;
}

static int sc92031_stop(struct net_device *dev)
{
	struct sc92031_priv *priv = netdev_priv(dev);
	struct pci_dev *pdev = priv->pdev;

	netif_tx_disable(dev);

	/* Disable interrupts, stop Tx and Rx. */
	sc92031_disable_interrupts(dev);

	spin_lock_bh(&priv->lock);

	_sc92031_disable_tx_rx(dev);
	_sc92031_tx_clear(dev);
	mmiowb();

	spin_unlock_bh(&priv->lock);

	free_irq(pdev->irq, dev);
	pci_free_consistent(pdev, TX_BUF_TOT_LEN, priv->tx_bufs,
			priv->tx_bufs_dma_addr);
	pci_free_consistent(pdev, RX_BUF_LEN, priv->rx_ring,
			priv->rx_ring_dma_addr);

	return 0;
}

static void sc92031_set_multicast_list(struct net_device *dev)
{
	struct sc92031_priv *priv = netdev_priv(dev);

	spin_lock_bh(&priv->lock);

	_sc92031_set_mar(dev);
	_sc92031_set_rx_config(dev);
	mmiowb();

	spin_unlock_bh(&priv->lock);
}

static void sc92031_tx_timeout(struct net_device *dev)
{
	struct sc92031_priv *priv = netdev_priv(dev);

	/* Disable interrupts by clearing the interrupt mask.*/
	sc92031_disable_interrupts(dev);

	spin_lock(&priv->lock);

	priv->tx_timeouts++;

	_sc92031_reset(dev);
	mmiowb();

	spin_unlock(&priv->lock);

	/* enable interrupts */
	sc92031_enable_interrupts(dev);

	if (netif_carrier_ok(dev))
		netif_wake_queue(dev);
}

#ifdef CONFIG_NET_POLL_CONTROLLER
static void sc92031_poll_controller(struct net_device *dev)
{
	disable_irq(dev->irq);
	if (sc92031_interrupt(dev->irq, dev) != IRQ_NONE)
		sc92031_tasklet((unsigned long)dev);
	enable_irq(dev->irq);
}
#endif

static int sc92031_ethtool_get_settings(struct net_device *dev,
		struct ethtool_cmd *cmd)
{
	struct sc92031_priv *priv = netdev_priv(dev);
	void __iomem *port_base = priv->port_base;
	u8 phy_address;
	u32 phy_ctrl;
	u16 output_status;

	spin_lock_bh(&priv->lock);

	phy_address = ioread32(port_base + Miicmd1) >> 27;
	phy_ctrl = ioread32(port_base + PhyCtrl);

	output_status = _sc92031_mii_read(port_base, MII_OutputStatus);
	_sc92031_mii_scan(port_base);
	mmiowb();

	spin_unlock_bh(&priv->lock);

	cmd->supported = SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full
			| SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full
			| SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII;

	cmd->advertising = ADVERTISED_TP | ADVERTISED_MII;

	if ((phy_ctrl & (PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10))
			== (PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10))
		cmd->advertising |= ADVERTISED_Autoneg;

	if ((phy_ctrl & PhyCtrlSpd10) == PhyCtrlSpd10)
		cmd->advertising |= ADVERTISED_10baseT_Half;

	if ((phy_ctrl & (PhyCtrlSpd10 | PhyCtrlDux))
			== (PhyCtrlSpd10 | PhyCtrlDux))
		cmd->advertising |= ADVERTISED_10baseT_Full;

	if ((phy_ctrl & PhyCtrlSpd100) == PhyCtrlSpd100)
		cmd->advertising |= ADVERTISED_100baseT_Half;

	if ((phy_ctrl & (PhyCtrlSpd100 | PhyCtrlDux))
			== (PhyCtrlSpd100 | PhyCtrlDux))
		cmd->advertising |= ADVERTISED_100baseT_Full;

	if (phy_ctrl & PhyCtrlAne)
		cmd->advertising |= ADVERTISED_Autoneg;

	cmd->speed = (output_status & 0x2) ? SPEED_100 : SPEED_10;
	cmd->duplex = (output_status & 0x4) ? DUPLEX_FULL : DUPLEX_HALF;
	cmd->port = PORT_MII;
	cmd->phy_address = phy_address;
	cmd->transceiver = XCVR_INTERNAL;
	cmd->autoneg = (phy_ctrl & PhyCtrlAne) ? AUTONEG_ENABLE : AUTONEG_DISABLE;

	return 0;
}

static int sc92031_ethtool_set_settings(struct net_device *dev,
		struct ethtool_cmd *cmd)
{
	struct sc92031_priv *priv = netdev_priv(dev);
	void __iomem *port_base = priv->port_base;
	u32 phy_ctrl;
	u32 old_phy_ctrl;

	if (!(cmd->speed == SPEED_10 || cmd->speed == SPEED_100))
		return -EINVAL;
	if (!(cmd->duplex == DUPLEX_HALF || cmd->duplex == DUPLEX_FULL))
		return -EINVAL;
	if (!(cmd->port == PORT_MII))
		return -EINVAL;
	if (!(cmd->phy_address == 0x1f))
		return -EINVAL;
	if (!(cmd->transceiver == XCVR_INTERNAL))
		return -EINVAL;
	if (!(cmd->autoneg == AUTONEG_DISABLE || cmd->autoneg == AUTONEG_ENABLE))
		return -EINVAL;

	if (cmd->autoneg == AUTONEG_ENABLE) {
		if (!(cmd->advertising & (ADVERTISED_Autoneg
				| ADVERTISED_100baseT_Full
				| ADVERTISED_100baseT_Half
				| ADVERTISED_10baseT_Full
				| ADVERTISED_10baseT_H